## 可变长数组 char data[0]
在结构体最后放入char data[0]，可以让数组长度是可变的。
```c
struct buffer
{
  int data_len; // 长度
  char data[0]; // 起始地址
}
```

#### 测试
```c
 1 #include <stdio.h>
 2 #include <stdlib.h>
 3 #include <string.h>
 4 #include <stdint.h>
 5 
 6 typedef struct
 7 {
 8     int data_len;
 9     char data[0];
10 }buff_st_1;
11 
12 typedef struct
13 {
14     int data_len;
15     char *data;
16 }buff_st_2;
17 
18 typedef struct 
19 {
20     int data_len;
21     char data[];
22 }buff_st_3;
23 
24 int main()
25 {
26     printf("sizeof(buff_st_1)=%u\n", sizeof(buff_st_1));
27     printf("sizeof(buff_st_2)=%u\n", sizeof(buff_st_2));
28     printf("sizeof(buff_st_3)=%u\n", sizeof(buff_st_3));
29 
30     buff_st_1 buff1;
31     buff_st_2 buff2;
32     buff_st_3 buff3;
33 
34     printf("buff1 address:%p,buff1.data_len address:%p,buff1.data address:%p\n",
35         &buff1, &(buff1.data_len), buff1.data);
36 
37     printf("buff2 address:%p,buff2.data_len address:%p,buff2.data address:%p\n",
38         &buff2, &(buff2.data_len), buff2.data);
39 
40     printf("buff3 address:%p,buff3.data_len address:%p,buff3.data address:%p\n",
41         &buff3, &(buff3.data_len), buff3.data);
42 
43     return 0;
44 }

output:
sizeof(buff_st_1)=4
sizeof(buff_st_2)=16
sizeof(buff_st_3)=4
buff1 address:0x7fff96e59c40,buff1.data_len address:0x7fff96e59c40,buff1.data 
address:0x7fff96e59c44
buff2 address:0x7fff96e59c30,buff2.data_len address:0x7fff96e59c30,buff2.data 
address:(nil)
buff3 address:0x7fff96e59c50,buff3.data_len address:0x7fff96e59c50,buff3.data 
address:0x7fff96e59c54
```
可以观察到char data[0]、char data[]都不占空间，而char* data，要占一个指针大小的空间。
但data[0]的地址是紧接着结构体的地址，而data[]的地址却不是。