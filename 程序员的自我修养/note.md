# 常用工具介绍
## objdump
objdump: display information from object files.
Options:
- -h: Display summary information from the section headers of the object file.
- -x: Display all available header information, including the symbol table and relocation entries.  Using -x is equivalent to specifying all of -a -f -h -p -r -t.
- -s: Display the full contents of any sections requested.  By default all non-empty sections are displayed.
- -d: Display the assembler mnemonics for the machine instructions from objfile.  This option only disassembles those sections which are expected to contain instructions.

## size
size: list section sizes and total size.
Options:


# Chapter 1 温故而知新
### 1.5 使用虚拟内存的原因
不使用虚拟内存的缺点：
- **地址空间不隔离**，所有程序都可以直接访问物理内存地址，程序所使用的内存空间不是相互隔离的。恶意程序或者有bug的程序会访问到其他程序的内存地址，导致意外发生。
- **内存使用效率低**，由于没有有效的内存管理机制，程序所需要的空间是连续的。导致运行程序而内存不足时，会导致其他程序整个被切换出来以获取内存。这导致大量的数据在换入换出，效率低下。
- **程序运行的地址不确定**，因为每次程序运行时，都需要给它分配足够大的空闲区域，这个空闲区域的位置是不确定的。这个程序的编写造成了一定的麻烦，因为程序在编写时，它访问数据和指令跳转时的目标地址很多都是固定的，这涉及到重定位问题。

### 1.5.3 分页(Paging)
linux查看分页大小：getconf PAGE_SIZE。Ubuntu 16.0为 4096字节(4KB)。

分页：把地址空间人为地等分成固定大小的页。

### 1.6 多线程
使用多线程的好处：
- 某个操作可能要陷入长时间等待，等待的线程会进入睡眠状态，无法执行。多线程执行可以有效利用等待的时间。典型的例子是等待网络响应。
- 某个操作(常常是计算)会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。
- 程序逻辑本身就要求并发操作，例如一个多端下载器(例如 Bittorrent)。
- 多CPU或多核计算机，本身具备同时执行多个线程的能力，因此单线程程序无法全面地发挥计算机的全部计算能力。
- 相对于多进程应用，多线程在数据共享方面效率要高很多。

不断在处理器上切换不同的线程的行为称之**线程调度**。在线程调度中，线程通常拥有至少三种状态，分别是：
- 运行(Running): 此时线程正在执行。
- 就绪(Ready): 此时线程可以立刻运行，但CPU已被占用。
- 等待(Waiting): 此时线程正在等待某一个事件(通常是I/O或同步）发生，无法执行。

处于运行中线程拥有一段可以执行的时间，这段时间称为**时间片(Time Slice)**，当时间片用尽的时候，该进程将进入就绪状态。如果在时间片用尽之前进程就开始等待某事件，那么它
将进入等待状态。每当一个线程离开运行状态时，调度系统就会选择一个其他的就绪线程继续执行。在一个处于等待状态的线程所等待的事件发生后，该线程将进入就绪状态。
状态的转移如图：
!["线程状态切换"](./photo/schedule.png)

##### 双重检查锁定模式
["双重检查锁定模式"](https://zh.wikipedia.org/wiki/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E6%A8%A1%E5%BC%8F)

-----------------------------------------------

# Chatper 2 编译和链接
## 2.1 编译过程
编译过程可分为四个步骤：
1. 预处理（Prepressing）
2. 编译（Compilation）
3. 汇编（Assembly）
4. 链接（Linking）

GCC编译过程分解如下图所示：
!["编译过程分解"](./photo/compilation.png)

### 2.1.1 预处理
首先将源代码文件和相关的头文件，如stdio.h等被预编译器cpp预编译成一个.i文件或者.ii文件。
可以使用如下命令进行预编译：
- $gcc -E hello.c -o hello.i
- $cpp hello.c > hello.i

预编译过程主要处理那些源代码文件中的以"#"开始的预编译指令。比如"#include"、"#define"等，主要处理规则如下：
- 将所有的"#define"删除，并且展开所有的宏定义。
- 处理所有条件预编译指令，比如"#if"、"#ifdef"、"#elif"、"#else"、"#endif"。
- 处理"#include"预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他的文件。
- 删除所有的注释"//"和"/**/"。
- 添加行号和文件名标识，比如#2"hello.c"2，以便于编译时编译器产生调式用的行号信息及用于编译时所产生编译错误或警告时能够显示行号。
- 保留所有的#pragma编译器指令，因为编译器必须要使用它们。

经过预编译后的.i文件不包含任何宏定义，因为所有宏都展开了，并且包含的文件也已经被插入到.i文件中。所以当无法判定宏定义是否正确或者头文件包含是否正确时，
可以查看预编译后的文件来确定问题。

### 2.1.2 编译
编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件。上面的编译过程相当于如下命令：
- $gcc -S hello.i -o hello.s
- $gcc -S hello.c -o hello.s

### 2.1.3 汇编
汇编器将汇编代码转变成机器可以执行的指令。汇编过程可以调用汇编器as来完成：
- $as hello.s -o hello.o
- $gcc -c hello.s -o hello.o
- $gcc -c hello.c -o hello.o

### 2.1.4 链接
链接将所有.o文件链接起来得到可执行文件。

## 2.2 编译器做了什么
编译过程一般可以分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。如下图所示：
!["编译过程"](./photo/compile.png)

### 2.2.1 词法分析
首先源代码程序被输入到扫描器(Scanner)，扫描器只是简单的进行词法分析，运用一种类似于有限状态机(Finite State Machine)的算法将源代码的字符序列分割成一系列的记号(Token)。
比如源代码如下：
```c
array[index] = (index + 4) * (2 + 6)
```
上面代码总共包含了28个非空字符，经过扫描后，产生了16个记号，如下表所示：
**记号** | **类型**
:------|:-----
array | 标识符
[ | 左方括号
index | 标识符
] | 右方括号
= | 赋值
( | 左原括号
index | 标识符
+ | 加号
4 | 数字
) | 右圆括号
* | 乘号
( | 左圆括号
2 | 数字
+ | 加号
6 | 数字
) | 右圆括号

词法分析产生的记号一般可以分为如下几类：关键字、标识符、字面量（包含数字、字符串等）和特殊符号（如加号、等号）。在标识记号的同时，扫描器也完成了其他工作。比如将标识符存放在符号表，将数字、字符串常量存放在文字表，以备后面的步骤使用。

### 2.2.2 语法分析
语法分析器（Grammar Parser）将对由扫描器产生的记号进行语法分析，从而产生语法树（Syntax Tree）。整个分析过程采用了**上下文无关语法(Context-free Grammar)** 的分析手段。简单地讲，由语法分析器生成的语法树就是以表达式(Expression)为节点的树。上面例子中的语句就是一个有赋值表达式、加法表达式、乘法表达式、数组表达式、括号表达式组成的复杂语句。它在经过语法分析器以后形成如下图所示的语法树。
!["语法树"](./photo/parser.png)
如果出现了表达式不合法，比如各种括号不匹配、表达式中缺少操作符等，编译器就会报告语法分析阶段的错误。

### 2.2.3 语义分析
语法分析仅仅是完成了对表达式的语法层面的分析，但是它并不了解这个语句是否真正有意义。比如C语言里面两个指针做乘法运算是没有意义的，但是这个语句在语法上是合法的;比如同样一个指针和一个浮点数做乘法运算是否合法等。编译器所能分析的语义是静态语义(Static Semantic)，所谓静态语义是指在编译期可以确定的语义。与之对应的动态语义(Dynamic Semantic)就是只有在运行期才能确定的语义。

静态语义通常包括声明和类型的匹配，类型的转换。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点类型到整型的转换过程，语义分析过程中需要完成这个步骤。比如将一个浮点型赋值给一个指针的时候，语义分析就会发现这个类型不匹配，编译器将会报错。动态语义一般指在运行期出现的语义相关的问题，比如将0作为除数是一个运行期语义错误。

经过语义分析阶段后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。上面描述的语法树在经过语义分析阶段以后成为了如下图所示的形式：
!["标识语义后的语法树"](./photo/sematic.png)

### 2.2.4 中间语言生成
源码级优化器（Source Code Opitimizer）会在源代码级别进行优化。例如(2+6)这个表达式可以被优化掉，因为它的值在编译期就可以被确定。经过优化的语法树如下图所示：
!["优化后的语法树"](./photo/optimizer-tree.png)

直接在语法树上作优化比较困难，所以源代码优化器往往将整个语法树转换成中间代码（Itermediate Code），它是语法树的顺序表示，其实它已经十分接近目标代码了。但是它一般跟目标机器和运行时环境是无关的。如它不包含数据的尺寸、变量地址和寄存器的名字等。中间代码有很多种类型，在不同编译器中有着不同的形式，比较常见的有：三地址码（Three-address Code）和P-代码（P-Code）。

三地址码：
x = y op z
这个三地址码表示将变量y和z进行op操作以后，复制给x。这里的op操作可以是算术运算，比如加减乘除，也可以其他任何可以应用到y和z的操作。三地址码也得名于此，因为一个三地址码语句里有三个变量地址。上面例子中的语法树被翻译成三地址码后是这样的：
```c
t1 = 2 + 6
t2 = index + 4
t3 = t2 * t1
array[index] = t3
```
可以看到，为了使所有操作都符合三地址码形式，这里利用了几个临时变量：t1、t2、t3。在三地址码的基础上进行优化时，优化程序会将2+6的结果结算出来，得到t1=8，然后将后面代码中的t1替换成数字8。还可以省去一个临时变量t3，因为t2可以重复利用。经过优化后的代码如下：
```c
t2 = index + 4
t2 = t2 * 8
array[index] = t2
```
中间代码使得编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。

### 2.2.5 目标代码生成和优化
编译器后端主要包括代码生成器（Code Generator）和目标代码优化器（Target Code Optimizer）。

代码生成器将中间代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。对于上面例子中的中间代码，代码生成器可能会产生下面的代码序列（用x86的汇编语言来表示，并且假设index的类型为int型，array的类型为int型数组）：
```c
movl index, %ecx	; value of index to ecx
addl $4, %ecx		; ecx = ecx + 4
mull $8, %ecx		; ecx = ecx * 8
movl index, %eax	; value of index to eax
movl %ecx, array(,eax,4); array[index] = ecx
```
最后目标代码优化器对上述的目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。上面的例子中，乘法由一条相对复杂的基址比例变址寻址（Base Index Scale Addressing）的lea指令完成，随后由一条mov指令完成最后的赋值操作，这条mov指令的寻址方式与lea是一样的：
```c
movl index, %edx
leal 32(,%edx,8), %eax
movl %eax, array(,%edx,4)
```
当源代码最终被编译成了目标代码时，还有一个问题是：index和array的地址还没有确定。如果index和array的定义在跟上面的源代码同一编译单元里面，那么编译器可以为index和array分配空间，确定它们的地址。但如果是定义在其他的程序模块的话，就要涉及链接的问题。事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接的时候才能确定。

## 2.4 静态链接
人们把每个源代码模块独立地编译，然后按照需要将它们“组装”起来，这个组装模块的过程就是**链接(Linking)**。链接的过程主要包括了**地址和空间分配(Address and Storage Allocation)**、**符号决议(Symbol Resolution)**、和**重定位(Relocation)**等步骤。

每个模块的源代码文件(如.c)文件经过编译器编译成目标文件(Object File，一般扩展名为.o或.obj)，目标文件和库(Library)一起链接形成最终可执行文件。而最常见的库就是**运行时库(Runtime Library)**，它是支撑程序运行的基本函数的集合。库其实是一组目标文件的包，就是一些最常用的代码编译成目标文件后打包存放。

地址修成的过程也被叫做**重定位(Relocation)**，每个要被修正的地方叫一个**重定位入口(Relocation Entry)**。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的位置。

----------------

# Chatper 3 目标文件里有什么
## 3.1 目标文件的格式
PC平台流行的可执行文件格式（Executable）主要是Windows下的PE（Portable Executable）和Linux的ELF（Executable Linkable Format），它们都是COFF（Common file format）的变种。

动态链接库（DLL，Dynamic Linking Library）（Windows的.dll和Linux的.so）及静态链接库（Static Linking Library）（Windows的.lib和Linux的.a）文件都按照可执行文件格式存储。静态链接库稍有不同，它是把很多目标文件捆绑在一起，再加上一些索引形成一个文件。ELF文件标准里面把系统中采用ELF格式的文件归为下表所列举的四类：
**ELF文件类型** | **说明** | **实例**
:-----------|:----------|:------------
可重定位文件（Relocatable File）| 这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类 | Linux的.o、Windows的.obj
可执行文件（Executable File） | 这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文件，它们一般都没有扩展名 | 比如/bin/bash文件、Windows的.exe
共享目标文件（Shared Object File） | 这种文件包含了代码和数据，可以在以下两种情况使用。一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件。第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行 | Linux的.so，如/lib/glibc-2.5.so、Windows的DLL
核心转储文件（Core Dump File） | 当进程意外终止时，系统可以将该进程的地址空间的内容以及终止时的一些其他信息转储到核心转储文件 | Linux下的core dump

## 3.2 目标文件是什么样的
!["ELF"](./photo/ELF.png)
- File Header：它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息。File Header还包括了一个段表（Section Table），段表是一个描述文件中各个段的数组。段表描述了文件中各个段在文件中的偏移位置以及段的属性等，从段表中可以得到每个段的所有信息。
- 代码段（Code Section）：程序源代码编译后的机器指令经常被放在代码段里，代码段常见的名字有".code"或".text"。
- .data：已初始化的全局变量和局部静态变量都保存在.data段。
- .bss：未初始化的全局变量和局部静态变量一般放在.bss段里。.bss段只是为未初始化的全局变量和局部静态变量预留位置，它并没有内容，所以它在文件中不占据空间。但程序运行时它们确实是要占空间的，所以可执行文件必须记录所有未初始化的全局变量和局部静态变量的大小总和。

总体来说，程序源代码被编译后主要分成两种段：程序指令和程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据。数据和指令分段有如下好处：
- 当程序被加载后，数据和指令分别被映射到两个虚存区域。由于数据区域对进程来说是可读写的，而指令区域对进程来说是只读的，所以这两个虚存区域的权限分别可设置为可读写和只读。这样可以防止程序的指令被有意或无意地改写。
- CPU的缓存一般都被设计成数据缓存和指令缓存分离，所以程序的指令和数据被分开存放对CPU的缓存命中率提高有好处。
- 最重要的原因是当系统中运行着多个该程序的副本时，因为指令是一样的，所以内存中只需保存一份该程序的指令部分。对于指令这种只读区域是这样，对于其他的只读数据也一样。比如很多程序里面带有的图标、图片、文本等资源都是属于可以共享的。

## 3.3 挖掘SimpleSection.o
```c
/*
 * SimpleSection.c
 */
int printf(const char* format, ...);

int global_init_var = 84;
int global_uninit_var;

void func1(int i)
{
    printf("%d\n", i);
}


int main(void)
{
    static int static_var = 85;
    static int static_var2;
    int a = 1;
    int b;

    func1(static_var + static_var2 + a + b);
    return a;
}
```
!["SimpleSection.o"](./photo/SimpleSection.o.png)
SimpleSection.o的段除了最基本的代码段、数据段、BSS段以外，还有只读数据段(.rodata)、注释数据段(.comment)和堆栈提示段(.note.GNU-stack)等。"CONTENTS"、"ALLOC"等表示段的各种属性，"CONTENTS"表示该段在文件中存在。可以看到BSS段没有"CONTENTS"，表示它实际上在ELF文件中不存在内容。相应的段在ELF中的结构如下图所示：
!["SimpleSection.o"](./photo/table.png)

### 3.3.1 代码段
可以使用 objdump -s -d SimpleSection.o 查看代码段内容。
![](./chapter3/3.3.1.png)
可以观察到.text段的大小正好为0x55。

### 3.3.2 数据段和只读数据段
.data段保存的是哪些已经初始化了的全局变量和局部静态变量。SimpleSection.c代码里一共有两个这样的变量，分别是global_init_var和static_var。这两个变量每个4个字节，一个刚好8个字节，所以.data段的大小为8个字节。

SimpleSection.c里面调用"printf"的时候，用到了一个字符串常量"%d\n"，它是一种只读数据，所以它被放在了.rodata段。可以从输出结果看到"%d\n"这个段的4个字节刚好是这个字符串常量的ASCII字节序，最后以\0结尾。

.rodata段存放的是只读数据，一般是程序里面的只读变量(如const修饰的变量)和字符串常量。单独设立.rodata段有很多好处，不光是语义上支持了C++的const关键字，而且操作系统在加载的时候可以将.rodata段的属性映射成只读，这样对于这个段的任何修改操作都会被作为非法操作处理，保证了程序的安全性。

### 3.3.3 BSS段
.bss段存放的是未初始化的全局变量和局部静态变量，如上述代码中global_uninit_var和static_var2就是被存放在.bss段。但有些编译器不会把全局未初始化变量存放在.bss段，而是预留一个未定义的全局变量符号，等到最终链接成可执行文件时再在.bss段分配空间。所以可以看到.bss段目前只有4个字节大小。