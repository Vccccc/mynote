# Chapter 1 温故而知新
### 1.5 使用虚拟内存的原因
不使用虚拟内存的缺点：
- **地址空间不隔离**，所有程序都可以直接访问物理内存地址，程序所使用的内存空间不是相互隔离的。恶意程序或者有bug的程序会访问到其他程序的内存地址，导致意外发生。
- **内存使用效率低**，由于没有有效的内存管理机制，程序所需要的空间是连续的。导致运行程序而内存不足时，会导致其他程序整个被切换出来以获取内存。这导致大量的数据在换入换出，效率低下。
- **程序运行的地址不确定**，因为每次程序运行时，都需要给它分配足够大的空闲区域，这个空闲区域的位置是不确定的。这个程序的编写造成了一定的麻烦，因为程序在编写时，它访问数据和指令跳转时的目标地址很多都是固定的，这涉及到重定位问题。

### 1.5.3 分页(Paging)
linux查看分页大小：getconf PAGE_SIZE。Ubuntu 16.0为 4096字节(4KB)。

分页：把地址空间人为地等分成固定大小的页。

### 1.6 多线程
使用多线程的好处：
- 某个操作可能要陷入长时间等待，等待的线程会进入睡眠状态，无法执行。多线程执行可以有效利用等待的时间。典型的例子是等待网络响应。
- 某个操作(常常是计算)会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。
- 程序逻辑本身就要求并发操作，例如一个多端下载器(例如 Bittorrent)。
- 多CPU或多核计算机，本身具备同时执行多个线程的能力，因此单线程程序无法全面地发挥计算机的全部计算能力。
- 相对于多进程应用，多线程在数据共享方面效率要高很多。

不断在处理器上切换不同的线程的行为称之**线程调度**。在线程调度中，线程通常拥有至少三种状态，分别是：
- 运行(Running): 此时线程正在执行。
- 就绪(Ready): 此时线程可以立刻运行，但CPU已被占用。
- 等待(Waiting): 此时线程正在等待某一个事件(通常是I/O或同步）发生，无法执行。

处于运行中线程拥有一段可以执行的时间，这段时间称为**时间片(Time Slice)**，当时间片用尽的时候，该进程将进入就绪状态。如果在时间片用尽之前进程就开始等待某事件，那么它
将进入等待状态。每当一个线程离开运行状态时，调度系统就会选择一个其他的就绪线程继续执行。在一个处于等待状态的线程所等待的事件发生后，该线程将进入就绪状态。
状态的转移如图：
!["线程状态切换"](./photo/schedule.png)

##### 双重检查锁定模式
["双重检查锁定模式"](https://zh.wikipedia.org/wiki/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E6%A8%A1%E5%BC%8F)

# Chatper 2 编译和链接
## 2.1 编译过程
编译过程可分为四个步骤：
1. 预处理（Prepressing）
2. 编译（Compilation）
3. 汇编（Assembly）
4. 链接（Linking）

GCC编译过程分解如下图所示：
!["编译过程分解"](./photo/compilation.png)

### 2.1.1 预处理
首先将源代码文件和相关的头文件，如stdio.h等被预编译器cpp预编译成一个.i文件或者.ii文件。
可以使用如下命令进行预编译：
- $gcc -E hello.c -o hello.i
- $cpp hello.c > hello.i

预编译过程主要处理那些源代码文件中的以"#"开始的预编译指令。比如"#include"、"#define"等，主要处理规则如下：
