# Chapter 1 温故而知新
### 1.5 使用虚拟内存的原因
不使用虚拟内存的缺点：
- **地址空间不隔离**，所有程序都可以直接访问物理内存地址，程序所使用的内存空间不是相互隔离的。恶意程序或者有bug的程序会访问到其他程序的内存地址，导致意外发生。
- **内存使用效率低**，由于没有有效的内存管理机制，程序所需要的空间是连续的。导致运行程序而内存不足时，会导致其他程序整个被切换出来以获取内存。这导致大量的数据在换入换出，效率低下。
- **程序运行的地址不确定**，因为每次程序运行时，都需要给它分配足够大的空闲区域，这个空闲区域的位置是不确定的。这个程序的编写造成了一定的麻烦，因为程序在编写时，它访问数据和指令跳转时的目标地址很多都是固定的，这涉及到重定位问题。

### 1.5.3 分页(Paging)
linux查看分页大小：getconf PAGE_SIZE。Ubuntu 16.0为 4096字节(4KB)。

分页：把地址空间人为地等分成固定大小的页。

### 1.6 多线程
使用多线程的好处：
- 某个操作可能要陷入长时间等待，等待的线程会进入睡眠状态，无法执行。多线程执行可以有效利用等待的时间。典型的例子是等待网络响应。
- 某个操作(常常是计算)会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。
- 程序逻辑本身就要求并发操作，例如一个多端下载器(例如 Bittorrent)。
- 多CPU或多核计算机，本身具备同时执行多个线程的能力，因此单线程程序无法全面地发挥计算机的全部计算能力。
- 相对于多进程应用，多线程在数据共享方面效率要高很多。

不断在处理器上切换不同的线程的行为称之**线程调度**。在线程调度中，线程通常拥有至少三种状态，分别是：
- 运行(Running): 此时线程正在执行。
- 就绪(Ready): 此时线程可以立刻运行，但CPU已被占用。
- 等待(Waiting): 此时线程正在等待某一个事件(通常是I/O或同步）发生，无法执行。

处于运行中线程拥有一段可以执行的时间，这段时间称为**时间片(Time Slice)**，当时间片用尽的时候，该进程将进入就绪状态。如果在时间片用尽之前进程就开始等待某事件，那么它
将进入等待状态。每当一个线程离开运行状态时，调度系统就会选择一个其他的就绪线程继续执行。在一个处于等待状态的线程所等待的事件发生后，该线程将进入就绪状态。
状态的转移如图：
!["线程状态切换"](./photo/schedule.png)

##### 双重检查锁定模式
["双重检查锁定模式"](https://zh.wikipedia.org/wiki/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E6%A8%A1%E5%BC%8F)

-----------------------------------------------

# Chatper 2 编译和链接
## 2.1 编译过程
编译过程可分为四个步骤：
1. 预处理（Prepressing）
2. 编译（Compilation）
3. 汇编（Assembly）
4. 链接（Linking）

GCC编译过程分解如下图所示：
!["编译过程分解"](./photo/compilation.png)

### 2.1.1 预处理
首先将源代码文件和相关的头文件，如stdio.h等被预编译器cpp预编译成一个.i文件或者.ii文件。
可以使用如下命令进行预编译：
- $gcc -E hello.c -o hello.i
- $cpp hello.c > hello.i

预编译过程主要处理那些源代码文件中的以"#"开始的预编译指令。比如"#include"、"#define"等，主要处理规则如下：
- 将所有的"#define"删除，并且展开所有的宏定义。
- 处理所有条件预编译指令，比如"#if"、"#ifdef"、"#elif"、"#else"、"#endif"。
- 处理"#include"预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他的文件。
- 删除所有的注释"//"和"/**/"。
- 添加行号和文件名标识，比如#2"hello.c"2，以便于编译时编译器产生调式用的行号信息及用于编译时所产生编译错误或警告时能够显示行号。
- 保留所有的#pragma编译器指令，因为编译器必须要使用它们。

经过预编译后的.i文件不包含任何宏定义，因为所有宏都展开了，并且包含的文件也已经被插入到.i文件中。所以当无法判定宏定义是否正确或者头文件包含是否正确时，
可以查看预编译后的文件来确定问题。

### 2.1.2 编译
编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件。上面的编译过程相当于如下命令：
- $gcc -S hello.i -o hello.s
- $gcc -S hello.c -o hello.s

### 2.1.3 汇编
汇编器将汇编代码转变成机器可以执行的指令。汇编过程可以调用汇编器as来完成：
- $as hello.s -o hello.o
- $gcc -c hello.s -o hello.o
- $gcc -c hello.c -o hello.o

### 2.1.4 链接
链接将所有.o文件链接起来得到可执行文件。

## 2.2 编译器做了什么
编译过程一般可以分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。如下图所示：
!["编译过程"](./photo/compile.png)

### 2.2.1 词法分析
首先源代码程序被输入到扫描器(Scanner)，扫描器只是简单的进行词法分析，运用一种类似于有限状态机(Finite State Machine)的算法将源代码的字符序列分割成一系列的记号(Token)。
比如源代码如下：
```c
array[index] = (index + 4) * (2 + 6)
```
上面代码总共包含了28个非空字符，经过扫描后，产生了16个记号，如下表所示：
**记号** | **类型**
:------|:-----
array | 标识符
[ | 左方括号
index | 标识符
] | 右方括号
= | 赋值
( | 左原括号
index | 标识符
+ | 加号
4 | 数字
) | 右圆括号
* | 乘号
( | 左圆括号
2 | 数字
+ | 加号
6 | 数字
) | 右圆括号

词法分析产生的记号一般可以分为如下几类：关键字、标识符、字面量（包含数字、字符串等）和特殊符号（如加号、等号）。在标识记号的同时，扫描器也完成了其他工作。比如将标识符存放在符号表，将数字、字符串常量存放在文字表，以备后面的步骤使用。

### 2.2.2 语法分析
语法分析器（Grammar Parser）将对由扫描器产生的记号进行语法分析，从而产生语法树（Syntax Tree）。整个分析过程采用了**上下文无关语法(Context-free Grammar)** 的分析手段。简单地讲，由语法分析器生成的语法树就是以**表达式(Expression)**为节点的树。上面例子中的语句就是一个有赋值表达式、加法表达式、乘法表达式、数组表达式、括号表达式组成的复杂语句。它在经过语法分析器以后形成如下图所示的语法树。
!["语法树"](./photo/parser.png)
如果出现了表达式不合法，比如各种括号不匹配、表达式中缺少操作符等，编译器就会报告语法分析阶段的错误。

### 2.2.3 语义分析
语法分析仅仅是完成了对表达式的语法层面的分析，但是它并不了解这个语句是否真正有意义。比如C语言里面两个指针做乘法运算是没有意义的，但是这个语句在语法上是合法的;比如同样一个指针和一个浮点数做乘法运算是否合法等。编译器所能分析的语义是静态语义(Static Semantic)，所谓静态语义是指在编译期可以确定的语义。与之对应的动态语义(Dynamic Semantic)就是只有在运行期才能确定的语义。

静态语义通常包括声明和类型的匹配，类型的转换。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点类型到整型的转换过程，语义分析过程中需要完成这个步骤。比如将一个浮点型赋值给一个指针的时候，语义分析就会发现这个类型不匹配，编译器将会报错。动态语义一般指在运行期出现的语义相关的问题，比如将0作为除数是一个运行期语义错误。

经过语义分析阶段后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。上面描述的语法树在经过语义分析阶段以后成为了如下图所示的形式：
!["标识语义后的语法树"](./photo/sematic.png)

### 2.2.4 中间语言生成
源码级优化器（Source Code Opitimizer）会在源代码级别进行优化。例如(2+6)这个表达式可以被优化掉，因为它的值在编译期就可以被确定。经过优化的语法树如下图所示：
!["优化后的语法树"](./photo/optimizer-tree.png)

直接在语法树上作优化比较困难，所以源代码优化器往往将整个语法树转换成中间代码（Itermediate Code），它是语法树的顺序表示，其实它已经十分接近目标代码了。但是它一般跟目标机器和运行时环境是无关的。如它不包含数据的尺寸、变量地址和寄存器的名字等。中间代码有很多种类型，在不同编译器中有着不同的形式，比较常见的有：三地址码（Three-address Code）和P-代码（P-Code）。

三地址码：
x = y op z
这个三地址码表示将变量y和z进行op操作以后，复制给x。这里的op操作可以是算术运算，比如加减乘除，也可以其他任何可以应用到y和z的操作。三地址码也得名于此，因为一个三地址码语句里有三个变量地址。上面例子中的语法树被翻译成三地址码后是这样的：
```c
t1 = 2 + 6
t2 = index + 4
t3 = t2 * t1
array[index] = t3
```
可以看到，为了使所有操作都符合三地址码形式，这里利用了几个临时变量：t1、t2、t3。在三地址码的基础上进行优化时，优化程序会将2+6的结果结算出来，得到t1=8，然后将后面代码中的t1替换成数字8。还可以省去一个临时变量t3，因为t2可以重复利用。经过优化后的代码如下：
```c
t2 = index + 4
t2 = t2 * 8
array[index] = t2
```
中间代码使得编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端。

### 2.2.5 目标代码生成和优化
编译器后端主要包括代码生成器（Code Generator）和目标代码优化器（Target Code Optimizer）。

代码生成器将中间代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同的机器有着不同的字长、寄存器、整数数据类型和浮点数数据类型等。对于上面例子中的中间代码，代码生成器可能会产生下面的代码序列（用x86的汇编语言来表示，并且假设index的类型为int型，array的类型为int型数组）：
```c
movl index, %ecx	; value of index to ecx
addl $4, %ecx		; ecx = ecx + 4
mull $8, %ecx		; ecx = ecx * 8
movl index, %eax	; value of index to eax
movl %ecx, array(,eax,4); array[index] = ecx
```
最后目标代码优化器对上述的目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。上面的例子中，乘法由一条相对复杂的基址比例变址寻址（Base Index Scale Addressing）的lea指令完成，随后由一条mov指令完成最后的赋值操作，这条mov指令的寻址方式与lea是一样的：
```c
movl index, %edx
leal 32(,%edx,8), %eax
movl %eax, array(,%edx,4)
```
当源代码最终被编译成了目标代码时，还有一个问题是：index和array的地址还没有确定。如果index和array的定义在跟上面的源代码同一编译单元里面，那么编译器可以为index和array分配空间，确定它们的地址。但如果是定义在其他的程序模块的

