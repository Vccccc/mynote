# c++沉思录
## chapter 4 类设计者的核查表
### 类需要一个构造函数吗？
**类需要一个构造函数吗？** 有些类太简单，它们的结构就是它们的接口，所以不需要构造函数。但复杂的类则需要构造函数来隐藏它们的内部工作方式。
### 数据成员是私有的吗？
**数据成员是私有的吗？** 通常使用使用公有的数据成员不是什么好事，因为类设计者无法控制何时访问这些成员。例如，下面一个支持可变长矢量类：
```c
template<typename T> class Vector
{
public: 
  int length;
};
```
如果类设计者将矢量的长度当作一个成员变量，那么设计者就必须保证这个成员变量在任何时候都能够正确反应实际矢量的长度，因为没有办法知道类的使用者什么时候会来访问这个信息。如果长度在函数中是像这样实现的：
```c
template<typename T> class Vector
{
public: 
  int length() const;
};
```
那么除非用户调用函数 length，否则类 Vecotr 都不必计算长度。

### 类需要一个无参的构造函数吗？
如果一个类已经有了构造函数，而想声明该类的对象可以不必显式地初始化它们，则必须显示地写一个无参构造函数。例如:
```c
class Point
{
public:
  Point(int p, int q): x(p), y(q) {}
private:
  int x, y;
};
```
这里定义了一个有一个构造函数的类。除非这个类有一个不需要参数的构造函数，否则下面的语句就是非法的：
Point p;  //错误：没有初始化

如果一个类需要一个显式构造函数，如上面的 Point 类一般，则试图生成该类对象的数组是非法的：
Point pa[100]; // 错误
即使想要把类的所有实例都初始化，也应该考虑所付出的代价，是否值得为此禁用数组对象。

### 是不是每个构造函数初始化了所有的数据成员？
构造函数的用途就是用一种明确定义的状态来设置对象。对象的状态由对象的数据成员进行反映。因此，每个构造函数都要负责为所有的数据成员设置经过明确定义的值。当然，有时，类会有一些数据成员，它们只在它们的对象存在了一定时间之后才有意义。所以要多思考。

### 类需要析构函数吗？
并非所有有构造函数的类都需要有析构函数。如果深入思考一个类要做些什么，那么类是否需要析构函数的问题就十分明显了。应该想一想该类是否分配了资源，而这些资源又不会由成员函数自动释放。特别是那些构造函数里包含了 new 表达式的类，通常要在析构函数中加上相应的 delete 表达式，所以会需要一个析构函数。

### 类需要一个虚析构函数吗？
有些类需要虚析构函数只是为了声明它们的析构函数是虚的。当然，决不会用作基类的类是不需要虚析构函数的：任何虚函数只在继承的情况下才有用。但是，如果有一个类 B，派生了一个类 D，那么 B 何时需要一个虚析构函数？只要有人可能会对实际指向 D 类型对象的 B* 指针执行 delete 表达式，就需要给 B 加上一个虚析构函数。
即使 B 和 D 都没有虚函数，这也是需要的，例如：
```c
struct B
{
  string s;
};

struct D : B
{
  string t;
};

int main()
{
  B* bp = new D; // 这里没有问题
  delete dp; 	// 除非 B 有一个虚析构函数，否则将调用错误的析构函数！
}
```
这里，即使 B 没有虚成员函数，甚至根本没有任何成员函数，也必须有一个虚析构函数，否则 delete 会出错：
```c
struct B
{
  string s;
  virtual ~B(){}
};
```
虚析构函数通常是空的。

### 类需要复制构造函数吗？
很多时候答案是“不”，但有时候答案是“是”。关键在于复制该类的对象是否就相当于复制其数据成员和基类对象。如果并不相当，就需要复制构造函数。

如果类在构造函数内分配资源，则可能需要一个显式的复制构造函数来管理资源。有析构函数（除了空的虚析构函数外）的类通常是用析构函数来释放构造函数分配的资源，这通常也需要一个复制构造函数。一个典型的例子是类 String:
```c
class String
{
public:
  String();
  String(const char* s);
  // 其他成员函数
private: 
  char* data;
};
```
它需要一个析构函数，因为它的数据成员指向了必须由对应的对象释放的被动态分配的内存。出于同样的原因，它还需要一个显式的复制构造函数：没有的话，复制 String 对象就会以复制它的 data 成员的形式隐式地定义。复制完后，两个对象的 data 成员将指向同样的内存：当两个对象被销毁时，这个内存会被释放两次。

如果不想用户能复制该类，就使用 delete 修饰复制构造函数（可能还有赋值操作符）：
```c
class Thing
{
public:
  // ...
  Thing(const Thing&) = delete;
  Thing& operator=(const Thing&) = delete;
};
```

### 类需要一个赋值操作符吗
如果需要复制构造函数，同理多半也会需要一个赋值操作符。
类 X 的赋值操作符由 X::operator= 来定义。通常，operator= 应该返回一个 X&，并且由
return *this;
结束以保证与内建的赋值操作符一致。
#### 操作符能正确地将对象赋给对象本身吗
如果原对象和目标对象是同一个，而我们又奉行“先释放旧值，再赋值”的行事规程，那么就有可能还没有实施复制之前就把原对象销毁了。例如类String:
```
class String
{
public:
  String& operator=(const String& s);
private:
  char* data
};
```
很容易就用下面的方法来实现赋值：
```c
// 很明显但不正确的实现
String& String::operator=(const String& s)
{
  delete [] data;
  data = new char[strlen(s.data)+1];
  strcpy(data, s.data);
  return *this;
}
```
一旦把一个 String 对象赋值给它本身，这个方法就会彻底失败，因为 s 和 this 同指向同样的对象。避免这个问题可以显式地加以预防：
```c
// 正确的实现方法1
String& String::operator=(const String& s)
{
  if(&s != this)
  {
    delete [] data;
    data = new char[strlen(s.data)+1];
    strcpy(data, s.data);
  }
  return *this;
}
```
另一种可行的方法是将旧值保存起来，直到将源值复制完成：
```c
// 正确的实现方法2
String& String::operator=(const String& s)
{
  char* newdata = new char[strlen(s.data)+1];
  strcpy(newdata, s.data);
  delete [] data;
  data = newdata;
  return *this;
}
```

### 类需要定义关系操作符吗
通用库的容器类提供了诸如列表、集合和图等数据结构的泛型定义。这些容器依赖于它们所包含的元素类型的操作。通常要求容器能够判断两个值是否相等。还常常需要容器具有判断一个值是否大于或者小于另一个值的能力。
如果类逻辑上支持相等操作，那么提供 operator== 和 operator!= 就可能会有好处。类似地，如果类的值有某种排序关系，那么可能会想提供余下的关系操作符。即使不希望用户直接使用关系操作符，也可能需要这些关系操作符。只要想创建类型的有序集合，就必须提供关系操作符。
